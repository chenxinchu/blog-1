# 445.两个链表相加
## 题目
给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
你可以假设除了数字 0 之外，这两个数字都不会以零开头。
> 进阶：如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。


> 示例<br>
输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)<br>
输出：7 -> 8 -> 0 -> 7

## 解法
由于需要从低位开始加，然后进位。 因此可以采用栈来简化操作。
依次将两个链表的值分别入栈 stack1 和 stack2，然后相加入栈 stack，进位操作用一个变量 carried 记录即可。
最后根据 stack 生成最终的链表即可。

>也可以先将两个链表逆置，然后相加，最后将结果再次逆置。

## 关键点解析
栈的基本操作
carried 变量记录进位
循环的终止条件设置成stack.length > 0 可以简化操作
注意特殊情况， 比如 1 + 99 = 100

## 具体代码
```js
/**
 * Definition for singly-linked list.
 * function ListNode(val) {
 *     this.val = val;
 *     this.next = null;
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let m = [];
    let n = [];
    let k = [];
    let cur1 = l1;
    let cur2 = l2;
    let jw = 0;
    while(cur1){
        m.push(cur1.val)
        cur1 = cur1.next
    }
    while(cur2){
        n.push(cur2.val)
        cur2 = cur2.next
    }
    let ans = null
    while(m.length > 0 || n.length > 0){
        let x = Number(m.pop()) || 0
        let y = Number(n.pop()) || 0
        k.push((x+y+jw)%10)
        let cur = (x+y+jw)%10
        if(x+y+jw >= 10){
            jw = 1
        }else{
            jw = 0
        }
        
        let curnode = new ListNode(cur)
        curnode.next = ans
        ans = curnode
    }
    let l = new ListNode(1)
    if(jw == 1){
        l.next = ans
        return l
    }
    return ans
    // if(jw == 1){
    //     k.push(1)
    // }
    // const dummy = {};

    // let current = dummy;
  
    // while (k.length > 0) {
    //   current.next = {
    //     val: k.pop(),
    //     next: null
    //   };
  
    //   current = current.next;
    // }
    // console.log(dummy.next)
    // return dummy.next;
};
```

## 补链表逆转
- 双指针(从前往后变换指向)
- 递归(从后往前变换指向)
- 魔化的双指针



[参考链接](https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-shuang-zhi-zhen-di-gui-yao-mo-/)
